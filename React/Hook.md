## Hook
Hook은 함수형 컴포넌트에서 상태 값 및 다른 여러 기능을 사용하기 편리하게 해주는 메서드를 의미한다. Hook은 class가 아닌 function으로만 리액트를 사용할 수 있게 해주는 것이기 때문에 클래스형 컴포넌트에서는 동작하지 않는다.
### Hook 사용 규칙
Hook을 사용할 때는 두 가지 규칙을 준수해야만 한다.
#### 1. 리액트 함수의 최상위에서만 호출해야 한다.
반복문, 조건문, 중첩된 함수 내에서 Hook을 실행하면 예상한 대로 동작하지 않을 우려가 있다. 컴포넌트 안에는 useState나 useEffect 같은 Hook들이 여러 번 사용될 수 있는데 리액트는 Hook을 호출되는 순서대로 저장 해놓는다. 그런데 조건문, 반복문 안에서 Hook을 호출하게 되면 호출되는 순서대로 저장을 하기 어려워지고 결국 버그를 초래한다.
#### 2. 오직 리액트 함수 내에서만 사용되어야 한다.
리액트 함수형 컴포넌트나 커스텀 Hook이 아닌 다른 일반 Javascript 함수 안에서 호출해서는 안된다는 의미이다. 애초에 Hook은 리액트의 함수 컴포넌트 내에서 사용되도록 만들어진 메서드이기 때문에 근본적으로 일반 Javascript 함수 내에서는 정상적으로 돌아가지 않는다.
### Class Component
클래스형 컴포넌트는 복잡해질수록 이해하기 어려워졌고 컴포넌트 사이에서 상태 로직을 재사용하기 어렵다는 단점이 있었다. 또한 리액트의 클래스형 컴포넌트를 사용하기 위해서는 Javascript의 `this`키워드가 어떤 방식으로 동작하는지 알아야 하는데 이는 문법을 정확히 알지 못하면 동작 방식 자체를 정확히 이해하기 어렵게 만들곤 했다. 그래서 리액트는 점진적으로 함수형 컴포넌트로 넘어갔다. 이전까지의 함수형 컴포넌트는 클래스 컴포넌트와는 다르게 상태 값을 사용하거나 최적화할 수 있는 기능들이 조금 미진했는데 그 부분들을 보완하기 위해 Hook이라는 개념을 도입했다.

<br/>

## React Hooks
### useState

<br/>

### useEffect

<br/>

### useRef

<br/>

### useMemo
useMemo는 특정 값을 재사용하고자 할 때 사용하는 렌더링 최적화를 위한 Hook이다.
```jsx
function Calculator({value}){

	const result = calculate(value);

	return <>
      <div>
        {result}
      </div>
    </>;
}
```
위 컴포넌트는 props로 넘어온 value값을 calculate라는 함수에 인자로 넘겨서 result값을 구한 후 출력을 하고 있다. 만약 여기서 calculate가 내부적으로 복잡한 연산을 해야 하는 함수라서 계산된 값을 반환하는 데에 시간이 몇 초 이상 걸린다고 가정해보면 해당 컴포넌트는 렌더링을 할 때마다 이 함수를 계속해서 호출할 것이고 그때마다 시간이 몇 초 이상 소요 될 것이다.
```jsx
import { useMemo } from "react";

function Calculator({value}){

	const result = useMemo(() => calculate(value), [value]);

	return <>
      <div>
        {result}
      </div>
    </>;
}
```
렌더링을 할 때마다 value값이 계속 바뀌는 게 아니라고 가정했을때 이 값을 어딘가에 저장을 해뒀다가 다시 꺼내서 쓸 수만 있다면 굳이 calculate함수를 호출할 필요도 없을 것이다. 이런 식으로 `useMemo`를 호출하여 calculate를 감싸주면 이전에 구축된 렌더링과 새로 구축되는 렌더링을 비교해 value값이 동일한 경우에는 이전 렌더링의 value값을 그대로 재활용 할 수 있게된다. 이는 메모이제이션(Memoization)개념과 긴말한 관계가 있다.
#### Memoization
메모이제이션은 알고리즘에서 자주 나오는 개념이다. 기존에 수행한 연산의 결과값을 메모리에 저장을 해두고 동일한 입력이 들어오면 재활용하는 프로그래밍 기법을 말한다. 메모제이션을 적절히 사용한다면 굳이 중복 연산을 할 필요가 없기 때문에 앱의 성능을 최적화할 수 있다. useMemo는 이 개념을 이용해 복잡한 연산의 중복을 피하고 리액트 앱의 성능을 최적화 시킨다.

<br/>

### useCallback
useCallback 또한 useMemo와 마찬가지로 메모이제이션 기법을 이용한 Hook이다. useMemo는 값의 재사용을 위한 것이라면 useCallback은 함수의 재사용을 위한 Hook이다.
```jsx
function Calculator({x, y}){

	const add = () => x + y;

	return <>
      <div>
        {add()}
      </div>
    </>;
}
```
위 컴포넌트에는 add라는 함수가 선언이 되있는 상태이다. 이 함수는 props로 넘어온 x,y값을 더해 값을 출력하고 있다. 이 함수는 해당 컴포넌트가 렌더링 될 때마다 새롭게 만들어질 것이다. 해당 컴포넌트가 리렌더링 되더라도 x,y값이 바뀌지 않는다면 함수 또한 메모리 어딘가에 저장해 뒀다가 다시 꺼내서 쓸 수 있을것이다. useCallback을 사용하면 그 함수가 의존하는 값들이 바뀌지 않는 한 기존 함수를 계속해서 반환한다.
```js
function Calculator({x, y}){

	const add = useCallback(() => x + y, [x, y]);

	return <>
      <div>
        {add()}
      </div>
    </>;
}
```
useCallback만 사용해서는 useMemo에 비해 뛰어난 최적화를 느낄 수는 없다. 왜냐하면 useCallback은 함수를 호출하지 않는 Hook이 아니라 그저 메모리 어딘가에 함수를 저장하고 꺼내서 호출하는 Hook이기 때문이다. 따라서 단순히 컴포넌트 내에서 함수를 반복해서 생성하지 않기 위해 useCallback을 사용하는 것은 큰 의미가 없거나 오히려 손해인 경우도 있다. 자식 컴포넌트의 props로 함수를 전달해 줄 때 useCallback을 사용하기가 좋다.
#### useCallback과 참조 동등성
useCallback은 참조 동등성에 의존한다. 리액트는 Javascript언어로 만들어진 오픈소스 라이브러리이기 때문에 기본적으로 Javascript의 문법을 따라간다. Javascript에서 함수는 객체이다. 객체는 메모리에 저장할 때 값을 저장하는게 아니라 값의 주소를 저장하기 때문에 반환하는 값이 같을지라도 일치연산자로 비교했을 때 false가 출력된다. 리액트는 리렌더링 시 함수를 새로 만들어서 호출한다. 새로 만들어 호출된 함수는 기존의 함수와 같은 함수가 아니지만 useCallback을 이용해 함수 자체를 저장해서 다시 사용하면 함수의 메모리 주소 값을 저장했다가 다시 사용한다는 것과 같다고 볼 수 있다. 따라서 리액트 컴포넌트 함수 내에서 다른 함수의 인자로 넘기거나 자식 컴포넌트의 prop으로 넘길 때 예상치 못한 성능 문제를 막을 수 있다.

<br/>

[Built-in React Hooks - React](https://react.dev/reference/react)